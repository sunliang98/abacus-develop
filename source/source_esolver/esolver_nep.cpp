/**
 * @file esolver_nep.cpp
#include "source_io/module_parameter/parameter.h"
 * @brief Implementation of ESolver_NEP class for neuroevolution potential (NEP).
 *
 * This file contains the implementation of the ESolver_NEP class, which is used for solving the energy and forces in a
 * NEP simulation.
 * NEP is a method for training deep neural networks to accurately predict the potential energy surface of a
 * molecular system.
 *
 * For more information about NEP, see the following reference:
 * 1. https://gpumd.org/potentials/nep.html
 * 2. https://doi.org/10.1002/mgea.70028
 *
 * @author MoseyQAQ
 * @date 2025-10-10
 */
#include "esolver_nep.h"

#include "source_base/parallel_common.h"
#include "source_base/timer.h"
#include "source_io/output_log.h"
#include "source_io/cif_io.h"

#include <numeric>
#include <unordered_map>

using namespace ModuleESolver;

void ESolver_NEP::before_all_runners(UnitCell& ucell, const Input_para& inp)
{   
    nep_potential = 0.0;
    nep_force.create(ucell.nat, 3);
    nep_virial.create(3, 3);
    atype.resize(ucell.nat);
    _e.resize(ucell.nat);
    _f.resize(3 * ucell.nat);
    _v.resize(9 * ucell.nat);

    ModuleIO::CifParser::write(PARAM.globalv.global_out_dir + "STRU.cif", 
                               ucell, 
                               "# Generated by ABACUS ModuleIO::CifParser",
                               "data_?");

#ifdef __NEP
    /// determine the type map from STRU to NEP model
    type_map(ucell);
#endif
}

void ESolver_NEP::runner(UnitCell& ucell, const int istep)
{
    ModuleBase::TITLE("ESolver_NEP", "runner");
    ModuleBase::timer::tick("ESolver_NEP", "runner");

    // note that NEP are column major, thus a transpose is needed
    // cell
    std::vector<double> cell(9, 0.0);
    cell[0] = ucell.latvec.e11 * ucell.lat0_angstrom;
    cell[1] = ucell.latvec.e21 * ucell.lat0_angstrom;
    cell[2] = ucell.latvec.e31 * ucell.lat0_angstrom;
    cell[3] = ucell.latvec.e12 * ucell.lat0_angstrom;
    cell[4] = ucell.latvec.e22 * ucell.lat0_angstrom;
    cell[5] = ucell.latvec.e32 * ucell.lat0_angstrom;
    cell[6] = ucell.latvec.e13 * ucell.lat0_angstrom;
    cell[7] = ucell.latvec.e23 * ucell.lat0_angstrom;
    cell[8] = ucell.latvec.e33 * ucell.lat0_angstrom;

    // coord
    std::vector<double> coord(3 * ucell.nat, 0.0);
    int iat = 0;
    const int nat = ucell.nat;
    for (int it = 0; it < ucell.ntype; ++it)
    {
        for (int ia = 0; ia < ucell.atoms[it].na; ++ia)
        {
            coord[iat] = ucell.atoms[it].tau[ia].x * ucell.lat0_angstrom;
            coord[iat + nat] = ucell.atoms[it].tau[ia].y * ucell.lat0_angstrom;
            coord[iat + 2 * nat] = ucell.atoms[it].tau[ia].z * ucell.lat0_angstrom;
            iat++;
        }
    }
    assert(ucell.nat == iat);

#ifdef __NEP
    nep_potential = 0.0;
    nep_force.zero_out();
    nep_virial.zero_out();

    nep.compute(atype, cell, coord, _e, _f, _v);

    // unit conversion
    const double fact_e = 1.0 / ModuleBase::Ry_to_eV;
    const double fact_f = 1.0 / (ModuleBase::Ry_to_eV * ModuleBase::ANGSTROM_AU);
    const double fact_v = 1.0 / (ucell.omega * ModuleBase::Ry_to_eV);


    // potential energy
    nep_potential = fact_e * std::accumulate(_e.begin(), _e.end(), 0.0) ;
    GlobalV::ofs_running << " #TOTAL ENERGY# " << std::setprecision(11) << nep_potential * ModuleBase::Ry_to_eV << " eV"
                         << std::endl;
    
    // forces
    for (int i = 0; i < nat; ++i)
    {
        nep_force(i, 0) = _f[i] * fact_f;
        nep_force(i, 1) = _f[i + nat] * fact_f;
        nep_force(i, 2) = _f[i + 2 * nat] * fact_f;
    }

    // virial
    std::vector<double> v_sum(9, 0.0);
    for (int j = 0; j < 9; ++j)
    {
        for (int i = 0; i < nat; ++i)
        {
            int index = j * nat + i;
            v_sum[j] += _v[index];
        }
    }

    // virial -> stress
    for (int i = 0; i < 3; ++i)
    {
        for (int j = 0; j < 3; ++j)
        {
            nep_virial(i, j) = v_sum[3 * i + j] * fact_v;
        }
    }
#else
    ModuleBase::WARNING_QUIT("ESolver_NEP", "Please recompile with -D__NEP");
#endif
    ModuleBase::timer::tick("ESolver_NEP", "runner");
}

double ESolver_NEP::cal_energy()
{
    return nep_potential;
}

void ESolver_NEP::cal_force(UnitCell& ucell, ModuleBase::matrix& force)
{
    force = nep_force;
    ModuleIO::print_force(GlobalV::ofs_running, ucell, "TOTAL-FORCE (eV/Angstrom)", force, false);
}

void ESolver_NEP::cal_stress(UnitCell& ucell, ModuleBase::matrix& stress)
{
    stress = nep_virial;
    ModuleIO::print_stress("TOTAL-STRESS", stress, true, false, GlobalV::ofs_running);

    // external stress
    double unit_transform = ModuleBase::RYDBERG_SI / pow(ModuleBase::BOHR_RADIUS_SI, 3) * 1.0e-8;
    double external_stress[3] = {PARAM.inp.press1, PARAM.inp.press2, PARAM.inp.press3};
    for (int i = 0; i < 3; i++)
    {
        stress(i, i) -= external_stress[i] / unit_transform;
    }
}

void ESolver_NEP::after_all_runners(UnitCell& ucell)
{
    GlobalV::ofs_running << "\n --------------------------------------------" << std::endl;
    GlobalV::ofs_running << std::setprecision(16);
    GlobalV::ofs_running << " !FINAL_ETOT_IS " << nep_potential * ModuleBase::Ry_to_eV << " eV" << std::endl;
    GlobalV::ofs_running << " --------------------------------------------\n\n" << std::endl;
}

#ifdef __NEP
void ESolver_NEP::type_map(const UnitCell& ucell)
{   
    // parse the element list from NEP model file
    std::unordered_map<std::string, int> label;
    std::string temp;
    for (int i = 0; i < nep.element_list.size(); ++i)
    {
        label[nep.element_list[i]] = i; //> label: map from element string to index int.
    }

    std::cout << "\n Element list of model file " << nep_file << " " << std::endl;
    std::cout << " ----------------------------------------------------------------";
    int count = 0;
    for (auto it = label.begin(); it != label.end(); ++it)
    {
        if (count % 5 == 0)
        {
            std::cout << std::endl;
            std::cout << "  ";
        }
        count++;
        temp = it->first + ": " + std::to_string(it->second);
        std::cout << std::left << std::setw(10) << temp;
    }
    std::cout << "\n -----------------------------------------------------------------" << std::endl;

    // parse the atype based on the element list
    int iat = 0;
    for (int it = 0; it < ucell.ntype; ++it)
    {
        for (int ia = 0; ia < ucell.atoms[it].na; ++ia)
        {
            if (label.find(ucell.atoms[it].label) == label.end())
            {
                ModuleBase::WARNING_QUIT("ESolver_NEP",
                                         "The label " + ucell.atoms[it].label + " is not found in the type map.");
            }
            atype[iat] = label[ucell.atoms[it].label];
            iat++;
        }
    }
    assert(ucell.nat == iat);
}
#endif
